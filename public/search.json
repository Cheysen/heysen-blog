[{"categories":["编程"],"content":"1. 枚举类型的介绍 枚举类型是一种特殊的数据类型，它使得变量成为一组预定义常量。所以在需要表示一组固定常量时应尽量使用枚举类型。通过关键字enum来定义枚举类，它和普通类一样可以有构造器、成员变量、方法。\n1.1 枚举类的特性  所有的枚举类都隐式的继承java.lang.Enum，Java不允许多继承，所以枚举类不能再继承其他任何类，但可以实现接口 枚举类被隐式地声明为final，所以也不能被其他任何类继承 枚举类型的构造函数修饰符必须是private。定义枚举常量时会自动调用，不能自己调用枚举的构造函数 枚举类的实例必须在第一行列出，并且枚举值默认被public static final修饰 编译时编译器会自动帮我们添加两个静态方法values()和valueOf()  1.2 枚举类的原理 下面我们定义了一个枚举类并让它实现Info接口，这样可以让枚举值提供不同的实现，当然也可以在枚举类里面定义一个抽象方法，这样枚举值也必须实现此抽象方法才可，效果都一样。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  public enum Season implements Info{ SPRING(\"spring\",\"春暖花开\"){ public void show(){ System.out.println(\"春天在哪里\"); } }, SUMMER(\"summer\",\"夏日炎炎\"){ public void show(){ System.out.println(\"生如夏花\"); } }, AUTUMN(\"autumn\",\"秋高气爽\"){ public void show(){ System.out.println(\"秋\"); } }, WINTER(\"winter\",\"白雪茫茫\"){ public void show(){ System.out.println(\"冷\"); } }; private final String seasonName; private final String seasonDesc; Season(String seasonName,String seasonDesc){ this.seasonName = seasonName; this.seasonDesc = seasonDesc; } public String getSeasonName() { return seasonName; } public String getSeasonDesc() { return seasonDesc; } @Override public String toString() { return \"Season{\" + \"seasonName='\" + seasonName + '\\'' + \", seasonDesc='\" + seasonDesc + '\\'' + '}'; } }   可以看到该枚举类编译后的class文件，其中还包括了四个枚举值对应的class文件，而且其后还带有序号。在枚举实例创建时会给每个枚举值指定一个整形常量值（序号），若没有显示指定，则 整形常量值从0开始递增。这其实是与父类Enum有关，后面会介绍。\n下面是利用javap工具查看Season.java经过编译后的字节码（请忽略乱码--.--）:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130  \"C:\\Program Files\\Java\\jdk1.8.0_201\\bin\\javap.exe\" -c pre.chl.enums.Season Compiled from \"Season.java\" public abstract class pre.chl.enums.Season extends java.lang.Enum\u003cpre.chl.enums.Season\u003e implements pre.chl.enums.Info { public static final pre.chl.enums.Season SPRING; public static final pre.chl.enums.Season SUMMER; public static final pre.chl.enums.Season AUTUMN; public static final pre.chl.enums.Season WINTER; public static pre.chl.enums.Season[] values(); Code: 0: getstatic #2 // Field $VALUES:[Lpre/chl/enums/Season;  3: invokevirtual #3 // Method \"[Lpre/chl/enums/Season;\".clone:()Ljava/lang/Object;  6: checkcast #4 // class \"[Lpre/chl/enums/Season;\"  9: areturn public static pre.chl.enums.Season valueOf(java.lang.String); Code: 0: ldc #5 // class pre/chl/enums/Season  2: aload_0 3: invokestatic #6 // Method java/lang/Enum.valueOf:(Ljava/lang/Class;Ljava/lang/String;)Ljava/lang/Enum;  6: checkcast #5 // class pre/chl/enums/Season  9: areturn public java.lang.String getSeasonName(); Code: 0: aload_0 1: getfield #8 // Field seasonName:Ljava/lang/String;  4: areturn public java.lang.String getSeasonDesc(); Code: 0: aload_0 1: getfield #9 // Field seasonDesc:Ljava/lang/String;  4: areturn public java.lang.String toString(); Code: 0: new #10 // class java/lang/StringBuilder  3: dup 4: invokespecial #11 // Method java/lang/StringBuilder.\"\u003cinit\u003e\":()V  7: ldc #12 // String Season{seasonName='  9: invokevirtual #13 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;  12: aload_0 13: getfield #8 // Field seasonName:Ljava/lang/String;  16: invokevirtual #13 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;  19: bipush 39 21: invokevirtual #14 // Method java/lang/StringBuilder.append:(C)Ljava/lang/StringBuilder;  24: ldc #15 // String , seasonDesc='  26: invokevirtual #13 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;  29: aload_0 30: getfield #9 // Field seasonDesc:Ljava/lang/String;  33: invokevirtual #13 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;  36: bipush 39 38: invokevirtual #14 // Method java/lang/StringBuilder.append:(C)Ljava/lang/StringBuilder;  41: bipush 125 43: invokevirtual #14 // Method java/lang/StringBuilder.append:(C)Ljava/lang/StringBuilder;  46: invokevirtual #16 // Method java/lang/StringBuilder.toString:()Ljava/lang/String;  49: areturn pre.chl.enums.Season(java.lang.String, int, java.lang.String, java.lang.String, pre.chl.enums.Season$1); Code: 0: aload_0 1: aload_1 2: iload_2 3: aload_3 4: aload 4 6: invokespecial #1 // Method \"\u003cinit\u003e\":(Ljava/lang/String;ILjava/lang/String;Ljava/lang/String;)V  9: return static {}; Code: 0: new #17 // class pre/chl/enums/Season$1  3: dup 4: ldc #18 // String SPRING  6: iconst_0 7: ldc #19 // String spring  9: ldc #20 // String ��ů����  11: invokespecial #21 // Method pre/chl/enums/Season$1.\"\u003cinit\u003e\":(Ljava/lang/String;ILjava/lang/String;Ljava/lang/String;)V  14: putstatic #22 // Field SPRING:Lpre/chl/enums/Season;  17: new #23 // class pre/chl/enums/Season$2  20: dup 21: ldc #24 // String SUMMER  23: iconst_1 24: ldc #25 // String summer  26: ldc #26 // String ��������  28: invokespecial #27 // Method pre/chl/enums/Season$2.\"\u003cinit\u003e\":(Ljava/lang/String;ILjava/lang/String;Ljava/lang/String;)V  31: putstatic #28 // Field SUMMER:Lpre/chl/enums/Season;  34: new #29 // class pre/chl/enums/Season$3  37: dup 38: ldc #30 // String AUTUMN  40: iconst_2 41: ldc #31 // String autumn  43: ldc #32 // String �����ˬ  45: invokespecial #33 // Method pre/chl/enums/Season$3.\"\u003cinit\u003e\":(Ljava/lang/String;ILjava/lang/String;Ljava/lang/String;)V  48: putstatic #34 // Field AUTUMN:Lpre/chl/enums/Season;  51: new #35 // class pre/chl/enums/Season$4  54: dup 55: ldc #36 // String WINTER  57: iconst_3 58: ldc #37 // String winter  60: ldc #38 // String ��ѩãã  62: invokespecial #39 // Method pre/chl/enums/Season$4.\"\u003cinit\u003e\":(Ljava/lang/String;ILjava/lang/String;Ljava/lang/String;)V  65: putstatic #40 // Field WINTER:Lpre/chl/enums/Season;  68: iconst_4 69: anewarray #5 // class pre/chl/enums/Season  72: dup 73: iconst_0 74: getstatic #22 // Field SPRING:Lpre/chl/enums/Season;  77: aastore 78: dup 79: iconst_1 80: getstatic #28 // Field SUMMER:Lpre/chl/enums/Season;  83: aastore 84: dup 85: iconst_2 86: getstatic #34 // Field AUTUMN:Lpre/chl/enums/Season;  89: aastore 90: dup 91: iconst_3 92: getstatic #40 // Field WINTER:Lpre/chl/enums/Season;  95: aastore 96: putstatic #2 // Field $VALUES:[Lpre/chl/enums/Season;  99: return } Process finished with exit code 0   可以发现，一个枚举类在经过编译后变成了一个抽象类，同时添加了两个方法values()和valueOf(String)。这里还可以看到字节码中的构造函数多了两个参数，一个int型一个String型，这两个参数其实是Enum里面的。\n1.3 java.lang.Enum 下面是JDK1.8的实现，注释做了部分翻译。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213  package java.lang; import java.io.Serializable; import java.io.IOException; import java.io.InvalidObjectException; import java.io.ObjectInputStream; import java.io.ObjectStreamException; /** * 这是所有Java语言枚举类型的公共基类。 * * 有关枚举的更多信息，包括对枚举的描述、隐式声明由编译器合成的方法， * 可以见于\u003ccite\u003e Java＆trade;Language\u003c/ cite\u003e的第8、9节。 * 另外，使用枚举类型作为set的类型或作为Map中keys的类型时，java.util.EnumSet * 和java.util.EnumMap更加高效 * * @param \u003cE\u003e The enum type subclass * @author Josh Bloch * @author Neal Gafter * @see Class#getEnumConstants() * @see java.util.EnumSet * @see java.util.EnumMap * @since 1.5 */ public abstract class Enum\u003cE extends Enum\u003cE\u003e\u003e implements Comparable\u003cE\u003e, Serializable { /** * 枚举常量的名称，和枚举声明中声明的一致。 * 大多数程序员应该使用{@link #toString}方法而不是直接访问此字段。 */ private final String name; /** * Returns the name of this enum constant, exactly as declared in its * enum declaration. * * \u003cb\u003eMost programmers should use the {@link #toString} method in * preference to this one, as the toString method may return * a more user-friendly name.\u003c/b\u003e This method is designed primarily for * use in specialized situations where correctness depends on getting the * exact name, which will not vary from release to release. * * @return the name of this enum constant */ public final String name() { return name; } /** * 这个枚举常量的序数（它在枚举声明中的位置，分配给初始常量的序数为零）。 * 大多数程序员对此字段没有使用。它是专门设计的供复杂的基于枚举的数据结构使用\t* 的，例如{@link java.util.EnumSet}和{@link java.util.EnumMap}. */ private final int ordinal; /** * Returns the ordinal of this enumeration constant (its position * in its enum declaration, where the initial constant is assigned * an ordinal of zero). * * Most programmers will have no use for this method. It is * designed for use by sophisticated enum-based data structures, such * as {@link java.util.EnumSet} and {@link java.util.EnumMap}. * * @return the ordinal of this enumeration constant */ public final int ordinal() { return ordinal; } /** * 唯一的构造函数，程序员无法调用次构造函数。它由编译器在进行枚举类型声明时调用。 * * @param name - The name of this enum constant, which is the identifier * used to declare it. * @param ordinal - The ordinal of this enumeration constant (its position * in the enum declaration, where the initial constant is assigned * an ordinal of zero). */ protected Enum(String name, int ordinal) { this.name = name; this.ordinal = ordinal; } /** * Returns the name of this enum constant, as contained in the * declaration. This method may be overridden, though it typically * isn't necessary or desirable. An enum type should override this * method when a more \"programmer-friendly\" string form exists. * * @return the name of this enum constant */ public String toString() { return name; } /** * Returns true if the specified object is equal to this * enum constant. * * @param other the object to be compared for equality with this object. * @return true if the specified object is equal to this * enum constant. */ public final boolean equals(Object other) { return this==other; } /** * Returns a hash code for this enum constant. * * @return a hash code for this enum constant. */ public final int hashCode() { return super.hashCode(); } /** * 抛出CloneNotSupportedException。这保证了枚举永远不会被克隆，这保证它们的“单例状态”。 * * @return (never returns) */ protected final Object clone() throws CloneNotSupportedException { throw new CloneNotSupportedException(); } /** * Compares this enum with the specified object for order. Returns a * negative integer, zero, or a positive integer as this object is less * than, equal to, or greater than the specified object. * * Enum constants are only comparable to other enum constants of the * same enum type. The natural order implemented by this * method is the order in which the constants are declared. */ public final int compareTo(E o) { Enum\u003c?\u003e other = (Enum\u003c?\u003e)o; Enum\u003cE\u003e self = this; if (self.getClass() != other.getClass() \u0026\u0026 // optimization  self.getDeclaringClass() != other.getDeclaringClass()) throw new ClassCastException(); return self.ordinal - other.ordinal; } /** * Returns the Class object corresponding to this enum constant's * enum type. Two enum constants e1 and e2 are of the * same enum type if and only if * e1.getDeclaringClass() == e2.getDeclaringClass(). * (The value returned by this method may differ from the one returned * by the {@link Object#getClass} method for enum constants with * constant-specific class bodies.) * * @return the Class object corresponding to this enum constant's * enum type */ @SuppressWarnings(\"unchecked\") public final Class\u003cE\u003e getDeclaringClass() { Class\u003c?\u003e clazz = getClass(); Class\u003c?\u003e zuper = clazz.getSuperclass(); return (zuper == Enum.class) ? (Class\u003cE\u003e)clazz : (Class\u003cE\u003e)zuper; } /** * 返回指定枚举类型和名称的枚举常量，名称必须与声明的完全匹配。 * 无关的空白字符是不被允许的。 * \u003cp\u003eNote that for a particular enum type {@code T}, the * implicitly declared {@code public static T valueOf(String)} * method on that enum may be used instead of this method to map * from a name to the corresponding enum constant. 所有的枚举常量值可以通过调用隐式方法{@code public static T[] values()}获得。 * * @param \u003cT\u003e The enum type whose constant is to be returned * @param enumType the {@code Class} object of the enum type from which * to return a constant * @param name the name of the constant to return * @return the enum constant of the specified enum type with the * specified name * @throws IllegalArgumentException if the specified enum type has * no constant with the specified name, or the specified * class object does not represent an enum type * @throws NullPointerException if {@code enumType} or {@code name} * is null * @since 1.5 */ public static \u003cT extends Enum\u003cT\u003e\u003e T valueOf(Class\u003cT\u003e enumType, String name) { T result = enumType.enumConstantDirectory().get(name); if (result != null) return result; if (name == null) throw new NullPointerException(\"Name is null\"); throw new IllegalArgumentException( \"No enum constant \" + enumType.getCanonicalName() + \".\" + name); } /** * enum classes cannot have finalize methods. */ protected final void finalize() { } /** * 防止默认反序列化。 */ private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException { throw new InvalidObjectException(\"can't deserialize enum\"); } private void readObjectNoData() throws ObjectStreamException { throw new InvalidObjectException(\"can't deserialize enum\"); } }   引用API文档对Enum中一些方法（不包含继承Object的）的解释:\n   protected Object clone()抛出CloneNotSupportedException异常     int compareTo(E o)将此枚举与指定的对象比较以进行排序   boolean equals(Object other)如果指定的对象和此枚举常量相等就返回true   protected void finalize()枚举类不能有finalize方法   Class getDeclaringClass()返回和此枚举常量的枚举类型相对应的Class对象   int hashCode()返回此枚举常量的哈希值   String name()返回此枚举常量的名称,与其枚举声明中声明的一致   int ordinal()返回此枚举常量的序号(它在枚举声明中的位置,初始常量的序号默认为0)   String toString()返回声明中包含的枚举常量的名称   static \u003cT extends Enum\u003e valueOf(Class enumType,String name)返回指定名称和类型的枚举常量    这里有一点需要注意的是，我们不能在定义的枚举类型的构造器里调用父类Enum的构造器，这是不被允许的，在编译器编译时会自动帮我们调用去初始化枚举值的声明。虽然Enum是一个抽象类，但是自定义枚举类型仍然会在编译阶段使用Enum的构造函数，不过在创建子类对象时到底有没有创建父类对象还存在分歧，具体可以看看知乎上的这篇文章。\n2. 枚举类的使用 2.1 定义 1 2 3 4  public enum Day { SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY }   枚举值之间使用\",\"分隔，如果后面没有属性或方法，最后加不加\";\"都行。但如果有就一定要加\";\"\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  public enum PurOrderSplitEnum { NORELEASEERPBILLCOUNT(\"1\", \"待发布\"), RELEASEERPBILLCOUNT(\"2\", \"待买方确认\"), PURCONFIRMINGCOUNT(\"3\", \"买方变更中\"); private String code; private String name; public static Map\u003cString, String\u003e code2name = new HashMap(); public static Map\u003cString, String\u003e code2Muname = new HashMap(); private PurOrderSplitEnum(String code, String name) { this.code = code; this.name = name; } public String getCode() { return this.code; } public String getName() { return this.name; } static { code2name.put(NORELEASEERPBILLCOUNT.getCode(), NORELEASEERPBILLCOUNT.getName()); code2name.put(RELEASEERPBILLCOUNT.getCode(), RELEASEERPBILLCOUNT.getName()); code2name.put(PURCONFIRMINGCOUNT.getCode(), PURCONFIRMINGCOUNT.getName()); code2Muname.put(NORELEASEERPBILLCOUNT.getCode(), \"NORELEASEERPBILLCOUNT\"); code2Muname.put(RELEASEERPBILLCOUNT.getCode(), \"RELEASEERPBILLCOUNT\"); code2Muname.put(PURCONFIRMINGCOUNT.getCode(), \"PURCONFIRMINGCOUNT\"); } }   2.2 结合Switch 在switch中使用枚举，可以让我们的代码可读性更好\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  public class EnumTest { Day day; public EnumTest(Day day) { this.day = day; } public void tellItLikeItIs() { switch (day) { case MONDAY: System.out.println(\"周一还行吧\"); break; case FRIDAY: System.out.println(\"周五很nice\"); break; case SATURDAY: case SUNDAY: System.out.println(\"周末超级棒\"); break; default: System.out.println(\"额....\"); break; } } public static void main(String[] args) { EnumTest firstDay = new EnumTest(Day.MONDAY); firstDay.tellItLikeItIs(); EnumTest thirdDay = new EnumTest(Day.WEDNESDAY); thirdDay.tellItLikeItIs(); EnumTest fifthDay = new EnumTest(Day.FRIDAY); fifthDay.tellItLikeItIs(); EnumTest sixthDay = new EnumTest(Day.SATURDAY); sixthDay.tellItLikeItIs(); EnumTest seventhDay = new EnumTest(Day.SUNDAY); seventhDay.tellItLikeItIs(); } //输出结果  /* 周一还行吧 额.... 周五很nice 周末超级棒 周末超级棒 */   2.3 valueOf方法 把字符串转成对应类型的枚举值，如：\n1 2 3 4  String str = \"SPRING\"; Season season2 = Season.valueOf(str); //Season season2 = Season.valueOf(Season.class,str);跟上面是等价的  System.out.println(season2 == season1);//true   2.4 values()和其他方法 values()方法可以返回所有定义的枚举值，name()方法返回的是枚举的名称，不是枚举值里面的属性名称，这里需要注意一下。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  Season season1 = Season.SPRING; for(Season season:Season.values()){ System.out.println(season); } season1.show(); System.out.println(season1.name()); System.out.println(\"SPIRNG的序号:\" + season1.ordinal()); //输出结果 /* Season{seasonName='spring', seasonDesc='春暖花开'} Season{seasonName='summer', seasonDesc='夏日炎炎'} Season{seasonName='autumn', seasonDesc='秋高气爽'} Season{seasonName='winter', seasonDesc='白雪茫茫'} 春天在哪里 SPRING 0 */   2.5 使用接口组织枚举 在接口中定义枚举类，可以将数据分组。\n1 2 3 4 5 6 7 8 9 10 11  public interface Animal { enum Dog implements Animal { HUSKY,GOLDEN_RETRIEVER,ALASKAN_MALAMUTE } enum Cat implements Animal { PERSIAN,RAGDOLL,BIRMAN } } // Animal dog = Animal.Dog.ALASKAN_MALAMUTE; // Animal cat = Animal.Cat.BIRMAN;   2.6 EnumSet和EnumMap Set类型是枚举集或Map的key是枚举值时，使用这两者将会更加高效。这里只摘取Java API文档的部分说明，详细的方法大家可以自己查找文档。\nEnumMap\n 用于枚举类型键的专用Map实现。 枚举映射中的所有键必须来自创建映射时显式或隐式指定的单个枚举类型。 枚举映射在内部表示为数组。 这种表现非常紧凑和高效。\n枚举映射按其键的自然顺序（枚举常量的声明顺序）维护。 这反映在集合视图（keySet（），entrySet（）和values（））返回的迭代器中。\n集合视图返回的迭代器非常一致：它们永远不会抛出ConcurrentModificationException，它们可能会也可能不会显示迭代进行过程中对映射所做的任何修改的影响。\nKey不允许为null。 尝试插入null将抛出NullPointerException。 但是，尝试测试是否存在空键或删除空键将正常运行。 value允许为null。\n与大多数集合实现一样，EnumMap不同步。 如果多个线程同时访问枚举映射，并且至少有一个线程修改了映射，则应该在外部进行同步。 这通常通过在自然封装枚举映射的某个对象上同步来完成。 如果不存在此类对象，则应使用Collections.synchronizedMap（java.util.Map \u003cK，V\u003e）方法“包装”映射。 这最好在创建时完成，以防止意外的不同步访问：\nMap \u003cEnumKey，V\u003e m= Collections.synchronizedMap（new EnumMap \u003cEnumKey，V\u003e（...））;\n说明：所有基本操作都在恒定时间内执行。 它们很可能（虽然不能保证）比它们对应的HashMap更快。\n EnumSet\n 用于枚举类型的专用Set实现。 枚举集中的所有元素必须来自单个枚举类型，该类型在创建集时显式或隐式指定。 枚举集在内部表示为位向量。 这种表现非常紧凑和高效。 这个类的空间和时间性能应该足够好，以允许它作为传统的基于int的“位标志”的高性能、类型安全的替代品。 如果它们的参数也是枚举集，即使批量操作（例如containsAll和retainAll）也应该非常快速地运行。\n迭代器方法返回的迭代器以其自然顺序（枚举常量声明的顺序）遍历元素。 返回的迭代器是弱一致的：它永远不会抛出ConcurrentModificationException，它可能会也可能不会显示迭代进行过程中对集合所做的任何修改的影响。\n不允许使用空元素。 尝试插入null元素将抛出NullPointerException。 但是，尝试测试null元素的存在或删除一个元素将正常工作。\n与大多数集合实现一样，EnumSet不同步。 如果多个线程同时访问枚举集，并且至少有一个线程修改了该集，则应该在外部进行同步。 这通常通过在自然封装枚举集的某个对象上进行同步来实现。 如果不存在此类对象，则应使用Collections.synchronizedSet（java.util.Set \u003cT\u003e）方法“包装”该集合。 这最好在创建时完成，以防止意外的不同步访问：\nSet \u003cMyEnum\u003e s = Collections.synchronizedSet（EnumSet.noneOf（MyEnum.class））;\n说明：所有基本操作都在恒定时间内执行。 它们很可能（虽然不能保证）比它们对应的的HashSet快得多。 如果它们的参数也是枚举集，即使批量操作也会在恒定时间内执行。\n 2.7 使用枚举实现单例模式 基于枚举类型的特性，Effective Java建议使用枚举来实现单例模式。\n1 2 3 4 5 6  public enum Singleton{ INSTANCE; public void doSomething{ //...  } }   ","description":"","tags":["Java"],"title":"Java枚举类型介绍和使用","uri":"/archives/java%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/"},{"categories":["网络安全"],"content":"1. XSS简介 跨站脚本(Cross Site Script)为了避免与CSS混淆,简称XSS。XSS是指攻击者利用网站没有对用户提交数据进行转义处理或者过滤不足的缺点，在输入框添加一些代码，嵌入到web页面中，使别的用户访问会执行相应的嵌入代码，从而盗取用户资料、利用用户身份进行某种动作或者对访问者进行病毒侵害的一种攻击方式。XSS又分为反射型、存储型和DOM-Based型。\nXSS的危害包括：\n  盗取用户Cookie\n  DDOS客户端浏览器\n  盗窃企业重要的具有商业价值的资料\n  爆发web2.0蠕虫\n  强制发送电子邮件\n  网站挂马，钓鱼攻击\n  劫持用户web行为甚至渗透内网\n  2. 原理 （1）反射型\n服务端返回脚本，客户端执行。如URL注入非法脚本，然后诱导用户点击该链接，但是一般浏览器都会有基本防御措施，自带拦截过滤；服务端返回的富文本中包含非法脚本，被直接展示。\r （2）存储型\n后台被动存储了非法脚本，并且前端直接展示。如发帖或留言中发出包含恶意代码的内容,其他用户访问该内容后,满足特定条件即触发,这种需要后台不过滤信息,并且前端展示时也不过滤信息。\r （3）DOM-Based型\n基于DOM或本地的XSS攻击。如wifi流量劫持、DNS劫持并直接返回钓鱼页面。本质是需要更改DOM，再排除自己攻击自己。某些反射型的攻击也能造成这个后果-通过url控制DOM。在传统的XSS中，恶意JavaScript脚本在页面加载时执行，而在基于DOM的XSS中，恶意JavaScript脚本在页面加载后的某个时刻执行。\r 3.自动化XSS Browser Exploitation Framework(BeEF),是目前强大的浏览器开源渗透测试框架,通过XSS漏洞配合JS脚本和Metasploit进行渗透。它是基于Ruby编写，支持图形化界面，操作简单。\nKali linux已经自带BeEF,另外我使用一个开源的靶机OWASP Broken Web Apps来练习。\n在靶机的低安全级别下执行一个存储型的XSS：\n然后使用win10的Google浏览器访问靶机的相应被注入脚本的页面后，BeEF中的记录：\n之后就可以使用beef控制用户的浏览器进行多种操作（比如钓鱼），但是这里并没有win10的记录，原因是chrome对该XSS进行了过滤。\n4. 如何预防 （1）编码，转义用户输入，编码可在前端和后端中进行。常见的如下图的HTML转义\n但是编码并不适用所有情况，比如当用户需要提供一个URL或者编写用户配置文件时，对输入编码是不友好的，不应对用户的自定义配置做限制，所以需要使用验证。\n（2）验证，过滤用户输入。有两种实现方式\n  分类策略，使用白名单或黑名单分类\n  验证结果，拒绝或删除不合法的输入\n  （3）CSP内容安全策略（CSP）\nCSP用于约束浏览器只能使用从可信来源下载的资源。资源是页面引用的脚本，样式表，图像或其他类型的文件。这样即使攻击者成功将恶意内容注入到网站，CSP也可以防止它被执行。\nCSP可用于执行以下规则：\n  没有不受信任的来源。外部资源只能从一组明确定义的可信来源加载。\n  没有内联资源。不会评估内联JavaScript和CSS。\n  无法使用JavaScript eval函数。\n  1 2 3 4 5  Content‑Security‑Policy: script‑src 'self' scripts.example.com; media‑src 'none'; img‑src *; default‑src 'self' http://*.example.com   以上CSP表明脚本只能从提供页面的主机和scripts.example.com下载。\n无法从任何地方下载音频和视频文件。可以从任何主机下载图像文件。\n所有其他资源只能从提供该页面的主机和example.com的任何子域下载。\n(4) 其他方法\n Cookie设置http-only。http-only标志可以防止cookie被“读取”，但不能防止被“写”,已证明有些浏览器的http-only标记可以被JavaScript写入覆盖，而这种覆盖可能被攻击者利用发动session fixation攻击。 WAF,大多数使用规则匹配,也能被绕过。 X-XSS-Protection也有助于在一些浏览器中防止某些XSS，但在某些情况下可以被绕过。  ","description":"","tags":["XSS"],"title":"浅谈XSS","uri":"/archives/%E6%B5%85%E8%B0%88xss/"},{"categories":["编程"],"content":"JMM(Java Memory Model),Java内存模型,它是一种Java虚拟机需要遵守的规范，定义了线程间如何在内存中正确地交互。JDK5以后的JMM规范在JSR-133中详细列出。\n1. 内存模型 1.1 为什么需要内存模型 多线程编程的困难在于很难对程序进行调式，如果控制不好，就会产生意料之外的结果。对于传统的单核CPU来说，由于是并发执行，即同一时刻只有一个线程在执行，所以一般不会出现数据的访问冲突。这也不是绝对的，单核多线程场景下，如果允许抢占式调度，仍存在线程安全问题。当前的处理器架构大多是多核+多级缓存+主存的模式，这样在多线程场景下就存在数据竞争从而造成缓存不一致的问题。另外CPU可能会对程序进行优化，进行指令重排序，只要重排后程序的语义没有发生变化，指令重排就是有可能发生的（编译器和JVM也存在指令重排），但这有时会让多线程执行的结果出乎意料。\n1.2 什么是内存模型  对处理器来说，内存模型定义了充分必要条件，以知道其他处理器对内存的写入对当前处理器可见，而当前处理器的写入对其他处理器可见。一些处理器使用强内存模型，即所有处理器在任何给定的内存位置上始终能看到完全相同的值,但这也不是绝对的,某些时候也需要使用特殊指令(称为内存屏障)来完成。其他处理器使用弱内存模型，需要内存屏障来刷新或使本地处理器缓存失效，以便查看其他处理器的写操作或使此处理器的写操作对其他处理器可见。这些内存屏障通常在lock和unlock时执行；对于使用高级语言的程序员来说，它们是不可见的。处理器的设计趋势是鼓励使用弱内存模型,因为它们的规范具有更强的可伸缩性。\n 1.3 其他语言有内存模型吗 大多数其他编程语言（如C和C ++）的设计并未直接支持多线程。 这些语言针对编译器和体系结构中发生的各种重排序提供的保护很大程度上取决于所使用的线程库（例如pthread），所使用的编译器以及运行代码的平台所提供的保证。\n2.Java内存模型 2.1 简介 Java内存模型是建立在内存模型之上的，它回答了当读取一个确定的字段时什么样的值是可见的。它将一个Java程序分解成若干动作（actions）并且为这些动作分配一个顺序。如果分配的这些顺序中能在对一个字段的写操作(write actions)和读操作(read actions)间形成一个叫happens-before的关系,那么Java内存模型保证了读操作将返回一个正确的值。\nJMM规定所有实例域、静态域和数组元素存储在JVM内存模型的的堆中，堆内存在线程间是共享的。局部变量和异常处理器参数不会共享，他们不存在内存可见性问题。每个线程创建时JVM都会为其创建一个工作内存(栈空间),工作内存是每个线程的私有数据区域,线程对变量的操作必须在工作内存中进行,首先要将变量从主内存拷贝到自己的工作内存空间,然后对变量进行操作,操作完成后再将变量写回主内存`,不能直接操作主内存中的变量,各个线程中的工作内存中存储着主内存中的变量副本拷贝,因此线程间的通信必须通过主内存来完成。\n2.2 代码优化问题 上面一段代码,模拟了两个线程。期望可能是thread1执行一次count++,thread2修改flag的值,然后thread1退出循环。但是在未做同步控制的情况下多线程的执行情况是无法预料的。还存在一个很重要的问题，那就是编译器优化（这里编译器可以是Java编译器如JIT，JVM，CPU）。\n 对于thread1，没有对flag的写操作，所以编译器认为flag的值总是true，就将flag直接改为true来提高程序运行速度，这种优化是被允许的，因为对于它本身而言没有改变程序语义。 对于thread2，没有要求对flag的值要刷回主存，编译器就可能优化为忽略对flag的写指令，因为不刷回主存的值改变只有线程自己可见。  2.3 指令重排序问题 对上图中三条指令，我们期望是顺序执行，但某些编译器为了提高速度，很可能对指令重排序变成下面一种执行顺序。\n再来看看下面的例子\n   处理器A 处理器B     a = 1; // 写操作A1 b =2; //写操作B1   x = b; //读操作A2 y = a; //读操作B2   初始状态 a = b = 0 结果 x = y = 0    之所以会出现以上结果,是因为处理器对写读指令进行了重排序,如将顺序A1 -\u003e A2重排成A2 -\u003e A1。对写读的重排序在x86架构下是被允许的。下图是不同架构下支持的重排序类型，这解释了为什么相同的程序在不同的架构系统下会产生不同的结果，因为编译器可能对你的代码进行了不同的重排序。\n另外重排序需要考虑到数据之间的依赖性，比如下面3条指令,3是不会排到指令1之前的,因为指令3依赖于指令1的数据x。\n1 2 3  int x = 1; //1 int y = 2; //2 y = x * x; //3   2.4 可见性问题 观察以上代码，写线程在自己的工作内存中改变了x的值却并未来得及刷回主内存,这样读线程读取到的值仍然是旧值,读线程此时对写线程的操作不可见。Java为此提供了volatile关键字解决方案：只要用volatile修饰变量x,对x进行原子操作后,x的值将立马刷回主内存,这样保证了读线程对写线程的可见性。\n2.5 原子性问题 Java中long型占8字节,也就是64位,如果在64位操作系统中执行以上代码不存在原子性问题,对foo的写操作一步完成,但是在32位操作系统中这种写操作就失去了原子性。32位操作系统中对foo的写操作分两步进行-分别对高32位和低32位进行写操作。在这种情况下就可能产生如下结果\n2.6 Happens-before规则 Happens-before表示动作上的偏序关系，官方文档对于该规则的定义如下 大致翻译一下就是:\n 两个动作可以由happends-before关系排序,如果一个动作happens-before另一个动作,那么第一个动作的执行结果对后一个动作可见。两个操作之间存在happens-before关系，并不意味着必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不非法。例如，在线程构造的对象的每个字段中写入默认值不需要在该线程的开始之前发生，只要没有读取操作就会观察到该事实。另外，当两个动作存在于不同的线程中时，也存在这种关系，此种情况下两者之间会存在一个消息传递机制。\n happens-before的8条规则如下：\n 程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。 监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。 volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。 传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。 start()规则：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。 join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。 程序中断规则：对线程interrupted()方法的调用先行于被中断线程的代码检测到中断时间的发生。 对象finalize规则：一个对象的初始化完成（构造函数执行结束）先行于发生它的finalize()方法的开始  2.7 实现    字段域 方法域     final synchronized(method/block)   volatile java.util.concurrent.*    volatile\n1 2 3 4 5 6 7 8 9 10 11 12  public class VolatileFieldsVisivility{ int a = 0; volatile int x = 0; public void writeThread(){ a = 1; //1  x = 1; //2  } public void readThread(){ int r2 = x; //3  int d1 = a; //4  } }   假设写线程执行完后,问读线程读变量a的值是1还是0还是不确定?答案是确定的1，即使变量a未用volatile修饰。由上面给出的happens-before规则可推得：1 happens-before 2, 2 happens-before 3 , 3 happens-before 4 --\u003e 1 happens-before 4(传递性),即读线程读a的时候一定能看到写线程的执行结果，简短来说就是当一个线程对volatile修饰的变量写入，并且读取时也是此变量时在他之前的所有写操作被保证对其他线程是可见的。值得注意的是,写读操作必须是原子性的,如果被volatile修饰的是long或者double,那么这个64位的变量不能被拆分存储。也就是说volatile保证了可见性和有序性,但不保证原子性。\n由于篇幅过长,其他方式的实现我将在其他文章中单独抽出来分析。\n3. 总结 Java内存模型就是Java语言在内存模型上的实现，它是为了保证多线程场景下的原子性、可见性和有序性提出的规范。Java语言提供了volatile、synchronized、final关键字和java.util.concurrent.*并发编程包来实现这些规范,这些提供给程序员的原语和包屏蔽了和底层交互的细节,让程序员可以更方便快捷地编程。\n","description":"","tags":["Java"],"title":"简单理解Java内存模型","uri":"/archives/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"}]
